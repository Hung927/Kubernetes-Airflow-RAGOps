import os
import ast
import ollama
import logging
from qdrant_client import QdrantClient, models


class Retrieval:
    def __init__(
        self, 
        embed_model: str = "imac/zpoint_large_embedding_zh"
    ):
        """
        Initialize the Retrieval class.
        
        Args:
            embed_model (str): The embedding model to be used. Defaults to "imac/zpoint_large_embedding_zh".
            **kwargs: Additional arguments.
        """
        try:
            self.embed_model = embed_model
            self.qdrant_client = QdrantClient(url=os.getenv("QDRANT_URL"))
        except Exception as e:
            logging.error(f"Error initializing Retrieval class: {e}")
            raise e
    
    @staticmethod
    def get_user_question(ti: object) -> str:
        """
        Get user question from XCom.
        
        Returns:
            user_question (str): The user's question.
        """
        try:
            user_question = ti.xcom_pull(task_ids='random_question_task', key='return_value')
            return user_question
        except Exception as e:
            logging.error(f"Error retrieving user question: {e}")
            return "What is the current number of electors currently in a Scottish Parliament constituency?"
      
    def collection_exists(self, collection_name: str) -> bool:
        """
        Check if the collection exists in Qdrant.
        
        Args:
            collection_name: Name of the collection to check
        
        Returns:
            bool: True if collection exists, False otherwise
        """
        try:
            if not any(collection.name == collection_name for collection in self.qdrant_client.get_collections().collections):
                logging.warning(f"Collection {collection_name} does not exist.")
                return False
            else:
                logging.info(f"Collection {collection_name} exists.")
                return True
        except Exception as e:
            logging.error(f"Error checking collection existence: {e}")
            return False
        
    def ollama_embedding(self, prompt: str) -> list:
        """
        Generate embedding using ollama.
        
        Args:
            prompt (str): Text prompt to generate embedding.
        
        Returns:
            query_vector (list): Embedding vector generated by ollama.
        """
        try:
            return ollama.embeddings(
                model=self.embed_model,
                prompt=prompt,
                options={"device": "cpu"},
                keep_alive="0s",
            )["embedding"]  
        except Exception as e:
            logging.error(f"Error generating embedding: {e}")
            raise e  
        
    def similarity_search(self, collection_name: str, prompt: str, limit: int = 5) -> list:
        """
        Perform similarity search in Qdrant.
        
        Args:
            collection_name (str): Name of the Qdrant collection.
            prompt (str): Text prompt to generate embedding.
            limit (int): Number of results to return. Defaults to 5.
        
        Returns:
            result (list): List of search results.
        """
        try:
            query_vector = self.ollama_embedding(
                prompt=prompt
            )
            result = self.qdrant_client.search(
                collection_name=collection_name,
                query_vector=query_vector,
                limit=limit,
                score_threshold=0
            )
            return result
        except Exception as e:
            logging.error(f"Error during similarity search: {e}")
            raise e

    def keyword_search(self, collection_name: str, prompt: str, keywords: list, limit: int = 5) -> list:
        """
        Perform keyword search in Qdrant.
        
        Args:
            collection_name (str): Name of the Qdrant collection.
            prompt (str): Text prompt to generate embedding.
            keywords (list): List of keywords to search for.
            limit (int): Number of results to return. Defaults to 5.
        
        Returns:
            result (list): List of search results.
        """
        try:
            condition = []
            query_vector = self.ollama_embedding(
                prompt=prompt
            )
            for keyword in keywords:
                condition.append(
                    models.FieldCondition(
                        key="document",
                        match=models.MatchText(text=keyword),
                    )
                )
            result = self.qdrant_client.search(
                collection_name=collection_name,
                query_vector=query_vector,
                limit=limit,
                score_threshold=0,
                query_filter=models.Filter(
                    must=condition
                ),
            )
            return result
        except Exception as e:
            logging.error(f"Error during keyword search: {e}")
            raise e
        
    def retrieval(self, types: str = "similarity", document_types: str = "squad", topk: int = 10, **kwargs) -> list:
        """
        Retrieve relevant documents from Qdrant based on the user question.
        
        Args:
            types (str): The type of retrieval. Defaults to "similarity".
            document_types (str): The type of documents to retrieve. Defaults to "squad".
            topk (int): Number of top results to retrieve. Defaults to 10.
            **kwargs: Additional arguments.
            
        Returns:
            search_result (list): A list of retrieved documents.
        """
        try:
            ti = kwargs['ti']
            user_question = self.get_user_question(ti)
            logging.info(f"Retrieving information for question: {user_question}")
            search_result = []
            
            collection_name = f"""{document_types}_{types}_{self.embed_model.split('/')[-1]}""" if types == "expert" else f"""{document_types}_{self.embed_model.split('/')[-1]}"""
            if not self.collection_exists(collection_name):
                logging.warning(f"Collection {collection_name} does not exist. Please check the collection name.")
                return []
            
            if types == "similarity":
                logging.info(f"Using similarity search")
                result = self.similarity_search(
                    collection_name=f"""{document_types}_{self.embed_model.split('/')[-1]}""",
                    prompt=user_question,
                    limit=topk
                )
            elif types == "expert":
                logging.info(f"Using expert search")
                result = self.similarity_search(
                    collection_name=f"""{document_types}_{types}_{self.embed_model.split('/')[-1]}""",
                    prompt=user_question,
                    limit=topk
                )
            elif types == "keyword":
                logging.info(f"Using keyword search")
                keyword_list = ti.xcom_pull(task_ids='keyword_extraction_task', key='return_value')
                logging.info(f"Keyword list: {keyword_list}")
                
                if isinstance(keyword_list, list):
                    keyword_list = keyword_list
                elif isinstance(keyword_list, str):
                    try:
                        keyword_list = ast.literal_eval(keyword_list)
                        if not isinstance(keyword_list, list):
                            keyword_list = [keyword_list]
                    except:
                        keyword_list = [keyword_list]
                else:
                    keyword_list = []
                    
                result = self.keyword_search(
                    collection_name=f"""{document_types}_{self.embed_model.split('/')[-1]}""",
                    prompt=user_question,
                    keywords=keyword_list,
                    limit=topk
                )
            
            key_to_extract = "answer" if types == "expert" else "document"
            for index in range(len(result)):
                search_result.append(f"""{result[index].payload[key_to_extract]}""")
            
            return search_result
        except Exception as e:
            logging.error(f"Error during retrieval: {e}")
            raise e
